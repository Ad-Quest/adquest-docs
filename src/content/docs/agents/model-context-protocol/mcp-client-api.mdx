---
title: Connecting to MCP servers
pcx_content_type: concept
tags:
  - MCP
sidebar:
  order: 7
---

import { Render, TypeScriptExample, LinkCard } from "~/components";

Connect your agent to external MCP (Model Context Protocol) servers to use their tools, resources, and prompts. This enables your agent to interact with GitHub, Slack, databases, and other services through a standardized protocol.

## Overview

The MCP client capability lets your agent:

- **Connect to external MCP servers** - GitHub, Slack, databases, AI services
- **Use their tools** - Call functions exposed by MCP servers
- **Access resources** - Read data from MCP servers
- **Use prompts** - Leverage pre-built prompt templates

:::note

This page covers connecting to MCP servers as a client. To create your own MCP server, refer to [Creating MCP servers](/agents/model-context-protocol/mcp-agent-api/).

:::

## Quick start

<TypeScriptExample>

```ts
import { Agent } from "agents";

export class MyAgent extends Agent {
	async onRequest(request: Request) {
		// Add an MCP server
		const result = await this.addMcpServer(
			"github",
			"https://mcp.github.com/mcp",
		);

		if (result.state === "authenticating") {
			// Server requires OAuth - redirect user to authorize
			return Response.redirect(result.authUrl);
		}

		// Server is ready - tools are now available
		const state = this.getMcpServers();
		console.log(`Connected! ${state.tools.length} tools available`);

		return new Response("MCP server connected");
	}
}
```

</TypeScriptExample>

Connections persist in the agent's [SQL storage](/agents/api-reference/store-and-sync-state/), and when an agent connects to an MCP server, all tools from that server become available automatically.

## Adding MCP servers

Use `addMcpServer()` to connect to an MCP server:

<TypeScriptExample>

```ts
// Simple connection
await this.addMcpServer("notion", "https://mcp.notion.so/mcp");

// With explicit callback host
await this.addMcpServer("github", "https://mcp.github.com/mcp", {
	callbackHost: "https://my-worker.workers.dev",
});
```

</TypeScriptExample>

### Transport options

MCP supports multiple transport types:

<TypeScriptExample>

```ts
await this.addMcpServer("server", "https://mcp.example.com/mcp", {
	transport: {
		type: "streamable-http",
	},
});
```

</TypeScriptExample>

| Transport         | Description                                         |
| ----------------- | --------------------------------------------------- |
| `streamable-http` | HTTP with streaming - recommended default           |
| `sse`             | Server-Sent Events - legacy/compatibility transport |
| `auto`            | Auto-detect based on server response                |

### Custom headers

For servers behind authentication (like Cloudflare Access) or using bearer tokens:

<TypeScriptExample>

```ts
await this.addMcpServer("internal", "https://internal-mcp.example.com/mcp", {
	transport: {
		headers: {
			Authorization: "Bearer my-token",
			"CF-Access-Client-Id": "...",
			"CF-Access-Client-Secret": "...",
		},
	},
});
```

</TypeScriptExample>

### Return value

`addMcpServer()` returns the connection state:

- `ready` - Server connected and tools discovered
- `authenticating` - Server requires OAuth; redirect user to `authUrl`

## OAuth authentication

Many MCP servers require OAuth authentication. The agent handles the OAuth flow automatically.

### How it works

```mermaid
sequenceDiagram
    participant Client
    participant Agent
    participant MCPServer

    Client->>Agent: addMcpServer(name, url)
    Agent->>MCPServer: Connect
    MCPServer-->>Agent: Requires OAuth
    Agent-->>Client: state: authenticating, authUrl
    Client->>MCPServer: User authorizes
    MCPServer->>Agent: Callback with code
    Agent->>MCPServer: Exchange for token
    Agent-->>Client: onMcpUpdate (ready)
```

### Handling OAuth in your agent

<TypeScriptExample>

```ts
class MyAgent extends Agent {
	async onRequest(request: Request) {
		const result = await this.addMcpServer(
			"github",
			"https://mcp.github.com/mcp",
		);

		if (result.state === "authenticating") {
			// Option 1: Redirect the user
			return Response.redirect(result.authUrl);

			// Option 2: Return the URL for client-side redirect
			return Response.json({
				status: "needs_auth",
				authUrl: result.authUrl,
			});
		}

		return Response.json({ status: "connected", id: result.id });
	}
}
```

</TypeScriptExample>

### OAuth callback

The callback URL is automatically constructed:

```txt
https://{host}/{agentsPrefix}/{agent-name}/{instance-name}/callback
```

For example: `https://my-worker.workers.dev/agents/my-agent/default/callback`

OAuth tokens are securely stored in SQLite, and persist across agent restarts.

### Custom OAuth callback handling

For custom OAuth completion behavior:

<TypeScriptExample>

```ts
export class MyAgent extends Agent {
	onStart() {
		this.mcp.configureOAuthCallback({
			// Redirect after successful auth
			successRedirect: "https://myapp.com/success",

			// Redirect on error
			errorRedirect: "https://myapp.com/error",

			// Or use a custom handler
			customHandler: (result) => {
				if (result.authSuccess) {
					// Close popup window after auth
					return new Response("<script>window.close();</script>", {
						headers: { "content-type": "text/html" },
					});
				}
				return new Response("Auth failed", { status: 400 });
			},
		});
	}
}
```

</TypeScriptExample>

## Using MCP capabilities

Once connected, access the server's capabilities:

### Getting available tools

<TypeScriptExample>

```ts
const state = this.getMcpServers();

// All tools from all connected servers
for (const tool of state.tools) {
	console.log(`Tool: ${tool.name}`);
	console.log(`  From server: ${tool.serverId}`);
	console.log(`  Description: ${tool.description}`);
}
```

</TypeScriptExample>

### Resources and prompts

<TypeScriptExample>

```ts
const state = this.getMcpServers();

// Available resources
for (const resource of state.resources) {
	console.log(`Resource: ${resource.name} (${resource.uri})`);
}

// Available prompts
for (const prompt of state.prompts) {
	console.log(`Prompt: ${prompt.name}`);
}
```

</TypeScriptExample>

### Server status

<TypeScriptExample>

```ts
const state = this.getMcpServers();

for (const [id, server] of Object.entries(state.servers)) {
	console.log(`${server.name}: ${server.state}`);
	// state: "ready" | "authenticating" | "connecting" | "connected" | "discovering" | "failed"
}
```

</TypeScriptExample>

### Integration with AI SDK

To use MCP tools with the Vercel AI SDK, use `this.mcp.getAITools()` which converts MCP tools to AI SDK format:

<TypeScriptExample>

```ts
import { generateText } from "ai";
import { openai } from "@ai-sdk/openai";

export class MyAgent extends Agent {
	async onRequest(request: Request) {
		const response = await generateText({
			model: openai("gpt-4"),
			prompt: "What's the weather in San Francisco?",
			tools: this.mcp.getAITools(), // Converts MCP tools to AI SDK format
		});

		return new Response(response.text);
	}
}
```

</TypeScriptExample>

:::note

`getMcpServers().tools` returns raw MCP `Tool` objects for inspection. Use `this.mcp.getAITools()` when passing tools to the AI SDK.

:::

## Managing servers

### Removing a server

<TypeScriptExample>

```ts
await this.removeMcpServer(serverId);
```

</TypeScriptExample>

This disconnects from the server and removes it from storage.

### Persistence

MCP servers persist across agent restarts:

- Server configuration stored in SQLite
- OAuth tokens stored securely
- Connections restored automatically when agent wakes

### Listing all servers

<TypeScriptExample>

```ts
const state = this.getMcpServers();

for (const [id, server] of Object.entries(state.servers)) {
	console.log(`${id}: ${server.name} (${server.server_url})`);
}
```

</TypeScriptExample>

## Client-side integration

Connected clients receive real-time MCP updates via WebSocket:

<TypeScriptExample>

```tsx
import { useAgent } from "agents/react";
import { useState } from "react";

function Dashboard() {
	const [tools, setTools] = useState([]);
	const [servers, setServers] = useState({});

	const agent = useAgent({
		agent: "MyAgent",
		onMcpUpdate: (mcpState) => {
			setTools(mcpState.tools);
			setServers(mcpState.servers);
		},
	});

	return (
		<div>
			<h2>Connected Servers</h2>
			{Object.entries(servers).map(([id, server]) => (
				<div key={id}>
					{server.name}: {server.connectionState}
				</div>
			))}

			<h2>Available Tools ({tools.length})</h2>
			{tools.map((tool) => (
				<div key={`${tool.serverId}-${tool.name}`}>{tool.name}</div>
			))}
		</div>
	);
}
```

</TypeScriptExample>

## API reference

### `addMcpServer()`

Add a connection to an MCP server and make its tools available to your agent.

```ts
async addMcpServer(
  serverName: string,
  url: string,
  options?: {
    callbackHost?: string;
    agentsPrefix?: string;
    client?: ClientOptions;
    transport?: {
      headers?: HeadersInit;
      type?: "sse" | "streamable-http" | "auto";
    };
  }
): Promise<
  | { id: string; state: "authenticating"; authUrl: string }
  | { id: string; state: "ready" }
>
```

#### Parameters

- `serverName` (string, required) — Display name for the MCP server
- `url` (string, required) — URL of the MCP server endpoint
- `options` (object, optional) — Connection configuration:
  - `callbackHost` — Host for OAuth callback URL. If omitted, automatically derived from the incoming request
  - `agentsPrefix` — URL prefix for OAuth callback path. Default: `"agents"`
  - `client` — MCP client configuration options (passed to `@modelcontextprotocol/sdk` Client constructor). By default, includes `CfWorkerJsonSchemaValidator` for validating tool parameters against JSON schemas
  - `transport` — Transport layer configuration:
    - `headers` — Custom HTTP headers for authentication
    - `type` — Transport type: `"streamable-http"` (default), `"sse"`, or `"auto"`

#### Returns

A Promise that resolves to a discriminated union based on connection state:

- When `state` is `"authenticating"`:
  - `id` (string) — Unique identifier for this server connection
  - `state` (`"authenticating"`) — Server is waiting for OAuth authorization
  - `authUrl` (string) — OAuth authorization URL for user authentication

- When `state` is `"ready"`:
  - `id` (string) — Unique identifier for this server connection
  - `state` (`"ready"`) — Server is fully connected and operational

### `removeMcpServer()`

Disconnect from an MCP server and clean up its resources.

```ts
async removeMcpServer(id: string): Promise<void>
```

#### Parameters

- `id` (string, required) — Server connection ID returned from `addMcpServer()`

### `getMcpServers()`

Get the current state of all MCP server connections.

```ts
getMcpServers(): MCPServersState
```

#### Returns

```ts
type MCPServersState = {
	servers: Record<
		string,
		{
			name: string;
			server_url: string;
			auth_url: string | null;
			state:
				| "authenticating"
				| "connecting"
				| "connected"
				| "discovering"
				| "ready"
				| "failed";
			capabilities: ServerCapabilities | null;
			instructions: string | null;
		}
	>;
	tools: Array<Tool & { serverId: string }>;
	prompts: Array<Prompt & { serverId: string }>;
	resources: Array<Resource & { serverId: string }>;
	resourceTemplates: Array<ResourceTemplate & { serverId: string }>;
};
```

The `state` field indicates the connection lifecycle:

- `authenticating` — Waiting for OAuth authorization to complete
- `connecting` — Establishing transport connection
- `connected` — Transport connection established
- `discovering` — Discovering server capabilities (tools, resources, prompts)
- `ready` — Fully connected and operational
- `failed` — Connection failed

## Advanced: MCPClientManager

For fine-grained control, use `this.mcp` directly:

### Step-by-step connection

<TypeScriptExample>

```ts
// 1. Register the server
await this.mcp.registerServer(id, {
	url: "https://mcp.example.com/mcp",
	name: "My Server",
	callbackUrl: "https://my-worker.workers.dev/agents/my-agent/default/callback",
	transport: { type: "auto" },
});

// 2. Connect
const connectResult = await this.mcp.connectToServer(id);

if (connectResult.state === "failed") {
	console.error("Connection failed:", connectResult.error);
	return;
}

if (connectResult.state === "authenticating") {
	// Handle OAuth...
	return;
}

// 3. Discover capabilities
const discoverResult = await this.mcp.discoverIfConnected(id);

if (!discoverResult?.success) {
	console.error("Discovery failed:", discoverResult?.error);
}
```

</TypeScriptExample>

### Event subscription

<TypeScriptExample>

```ts
// Listen for state changes
this.mcp.onServerStateChanged(() => {
	console.log("MCP server state changed");
	this.broadcastMcpServers(); // Notify connected clients
});
```

</TypeScriptExample>

### Lifecycle methods

#### `this.mcp.registerServer()`

Register a server without immediately connecting.

```ts
async registerServer(
  id: string,
  options: {
    url: string;
    name: string;
    callbackUrl: string;
    clientOptions?: ClientOptions;
    transportOptions?: TransportOptions;
  }
): Promise<string>
```

#### `this.mcp.connectToServer()`

Establish a connection to a previously registered server.

```ts
async connectToServer(id: string): Promise<MCPConnectionResult>

type MCPConnectionResult =
  | { state: "failed"; error: string }
  | { state: "authenticating"; authUrl: string }
  | { state: "connected" }
```

#### `this.mcp.discoverIfConnected()`

Check server capabilities if a connection is active.

```ts
async discoverIfConnected(
  serverId: string,
  options?: { timeoutMs?: number }
): Promise<MCPDiscoverResult | undefined>

type MCPDiscoverResult = {
  success: boolean;
  state: MCPConnectionState;
  error?: string;
}
```

#### `this.mcp.closeConnection()`

Close the connection to a specific server while keeping it registered.

```ts
async closeConnection(id: string): Promise<void>
```

#### `this.mcp.closeAllConnections()`

Close all active server connections while preserving registrations.

```ts
async closeAllConnections(): Promise<void>
```

#### `this.mcp.getAITools()`

Get all discovered MCP tools in a format compatible with the AI SDK.

```ts
getAITools(): ToolSet
```

Tools are automatically namespaced by server ID to prevent conflicts when multiple MCP servers expose tools with the same name.

## Error handling

Use error detection utilities to handle connection errors:

<TypeScriptExample>

```ts
import { isUnauthorized, isTransportNotImplemented } from "agents/mcp";

export class MyAgent extends Agent {
	async onRequest(request: Request) {
		try {
			await this.addMcpServer("Server", "https://mcp.example.com/mcp");
		} catch (error) {
			if (isUnauthorized(error)) {
				return new Response("Authentication required", { status: 401 });
			} else if (isTransportNotImplemented(error)) {
				return new Response("Transport not supported", { status: 400 });
			}
			throw error;
		}
	}
}
```

</TypeScriptExample>

## Next steps

<LinkCard
	title="Creating MCP servers"
	href="/agents/model-context-protocol/mcp-agent-api/"
	description="Build your own MCP server."
/>

<LinkCard
	title="Client SDK"
	href="/agents/api-reference/client-sdk/"
	description="Connect from browsers with onMcpUpdate."
/>

<LinkCard
	title="Store and sync state"
	href="/agents/api-reference/store-and-sync-state/"
	description="Learn about agent persistence."
/>
